/**
 * Объявляем переменные директивой let
 * @param a {number} Переменная инкремент
 * @param b {number} Переменная инкремент
 * @param c {number} Переменная
 * @param d {number} Переменная
 */
let a = 1, b = 1, c, d;

/**
 * # Пример 1
 * a - это префиксный инкремент
 */
c = ++a;
/**
 * Можно записать так:
 */
// a = a + 1;
// с = a;
console.log(c); // ответ: 2

/**
 * # Пример 2
 * b - это постфиксный инкремент
 */
d = b++;
/**
 * Можно записать так:
 */
// d = b;
// b = b + 1;
console.log(d) //ответ: 1

/**
 * # Пример 3
 * Выражение состоит из:
 * c - это переменная, изначально с типом undefined, т.к. она была объявлена, но не проинизиализирована, 
 * на этом этапе, она приняла значение 2.
 * a - это переменная, постфиксный инкремент. Она инициализирована значением типа number 1,
 * на этом этапе, она приняла значение 2.
 * 2 - число 2
 * 2 и ++a - операнды
 * + - оператор Сложения, приоритет 13
 * = - оператор Присваивания, приоритет 3
 * [Таблица](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
 * Порядок выполнения выражения в соответствии с приоритетом операторов:
 * * Рассчитывается ++a, т.к. ее можно представить в виде группировки (), а у этого оператора приоритет наивысших из всего выражения.
 * ++a на первой итерации возвращает (a + 1)
 * c = 2 + (2 + 1) = 5
 */
c = 2 + ++a;
console.log(c); //ответ: 5

/**
 * # Пример 4
 * b - это постфиксный инкремент. Она инициализирована значением типа number 1
 * на этом этапе, она приняла значение 2.
 * * Рассчитывается b++, т.к. ее можно представить в виде группировки (), а у этого оператора приоритет наивысших из всего выражения.
 * b++ на первой итерации возвращает результат 2, т.е. (b++) равен 2, а сам инкремент инекрементируется + 1, т.е. (b) равен 3.
 * d = 2 + (2)) = 4
 */
d = 2 + b++;
console.log(d); //ответ: 4
console.log(a); //3
console.log(b); //3